//视椎剔除+Hiz遮挡剔除
#pragma kernel GrassCulling

uint grassCount;
uint depthTextureSize;
StructuredBuffer<float4x4> grassMatrixBuffer;
bool isOpenGL;

float4 cameraPosition;
float4 cameraHalfFOVRadian;
float4x4 vpMatrix;
AppendStructuredBuffer<float4x4> cullResultBuffer;
Texture2D hizTexture;

static float3 boundMin = float3(-0.2f, 0.0f, -0.2f);
static float3 boundMax = float3(0.2f, 0.5f, 0.2f);
static float3x3 zRotateToxMatrix = float3x3(0, 0, 1, 0, 1 ,0, -1, 0, 0);

//在Clip Space下，根据齐次坐标做Clipping操作
bool IsInClipSpace(float4 clipSpacePosition)
{
    if (isOpenGL)
        return clipSpacePosition.x > -clipSpacePosition.w && clipSpacePosition.x < clipSpacePosition.w&&
        clipSpacePosition.y > -clipSpacePosition.w && clipSpacePosition.y < clipSpacePosition.w&&
        clipSpacePosition.z > -clipSpacePosition.w && clipSpacePosition.z < clipSpacePosition.w;
    else
        return clipSpacePosition.x > -clipSpacePosition.w && clipSpacePosition.x < clipSpacePosition.w&&
        clipSpacePosition.y > -clipSpacePosition.w && clipSpacePosition.y < clipSpacePosition.w&&
        clipSpacePosition.z > 0 && clipSpacePosition.z < clipSpacePosition.w;
}

[numthreads(640, 1, 1)]
void GrassCulling(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= grassCount) return;

    //单个草从View Space变换到World Space的矩阵，即M矩阵
    float4x4 grassMatrix = grassMatrixBuffer[id.x];
    //得到单个草的mvp矩阵
    float4x4 mvpMatrix = mul(vpMatrix, grassMatrix);
    
    //包围盒的8个顶点的View Space坐标
    float4 boundVerts[8];
    boundVerts[0] = float4(boundMin, 1);
    boundVerts[1] = float4(boundMax, 1);
    boundVerts[2] = float4(boundMax.x, boundMax.y, boundMin.z, 1);
    boundVerts[3] = float4(boundMax.x, boundMin.y, boundMax.z, 1);
    boundVerts[4] = float4(boundMax.x, boundMin.y, boundMin.z, 1);
    boundVerts[5] = float4(boundMin.x, boundMax.y, boundMax.z, 1);
    boundVerts[6] = float4(boundMin.x, boundMax.y, boundMin.z, 1);
    boundVerts[7] = float4(boundMin.x, boundMin.y, boundMax.z, 1);

    //-------------------------------------------------------视椎剔除-------------------------------------------------------
    //通过mvp矩阵得到顶点的Clip Space的齐次坐标，然后在Clip Space做视椎剔除判断，所有点都不在NDC内就被剔除。
    for (int i = 0; i < 8; i++)
    {
        if (IsInClipSpace(mul(mvpMatrix, boundVerts[i])))
            break;
        if (i == 7)
            return;
    }

    //-------------------------------------------------------Hiz遮挡剔除-------------------------------------------------------
    //获取每个草的深度采样点
    float3 cameraToGrass = normalize(grassMatrix._14_24_34 - cameraPosition.xyz);
    float3 samplePoint = float3(0, (boundMax.y - boundMin.y) * 0.5f, 0) + cameraToGrass * boundMin.x + mul(zRotateToxMatrix, cameraToGrass) * boundMin.x;
    float4 clipSpacePosition = mul(mvpMatrix, float4(samplePoint, 1.0f));
    //转换为NDC的坐标
    float3 NDCPosition = clipSpacePosition.xyz / clipSpacePosition.w;
    //-1到1转换为0到1的uv坐标
    float2 uv = NDCPosition.xy * 0.5f + 0.5f;
    //DirextX下NDC的z值即为深度（反转过的）
    float depth = NDCPosition.z;

    //if (isOpenGL)
        //uv.y = 1.0 - uv.y;

    //如果是OpenGL,则 *0.5+0.5 转换到 0-1 的值
    if (isOpenGL)
        depth = depth * 0.5f + 0.5f;

    //根据草的AABB高度计算当前草占用了多少个像素
    float heightInScreen = (boundMax.y - boundMin.y) / (tan(cameraHalfFOVRadian) * clipSpacePosition.w * 2) * depthTextureSize;
    //计算应该读取哪层mipmap
    uint mipmapLevel = (uint)clamp(log2(heightInScreen), 0, log2(depthTextureSize) - 4);
    //当前mipmap的大小
    uint size = depthTextureSize / (1 << mipmapLevel);
    uint2 pixel = uint2(clamp(uv.x * size, 0, size - 1), clamp(uv.y * size, 0, size - 1));

    float depthInTexture = hizTexture.mips[mipmapLevel][pixel].r;

    if (isOpenGL) {
        if (pixel.x < size - 1 && pixel.y < size - 1)
            depthInTexture = max(max(depthInTexture, hizTexture.mips[mipmapLevel][pixel + int2(0, 1)].r), max(hizTexture.mips[mipmapLevel][pixel + int2(1, 0)].r, hizTexture.mips[mipmapLevel][pixel + int2(1, 1)].r));
        if (depthInTexture < depth)
            return;
    }
    else {
        if (pixel.x < size - 1 && pixel.y < size - 1)
            depthInTexture = min(min(depthInTexture, hizTexture.mips[mipmapLevel][pixel + int2(0, 1)].r), min(hizTexture.mips[mipmapLevel][pixel + int2(1, 0)].r, hizTexture.mips[mipmapLevel][pixel + int2(1, 1)].r));
        if (depthInTexture > depth)
            return;
    }

    cullResultBuffer.Append(grassMatrix);
}